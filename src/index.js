const Parser = require('./parser')
const HtmlScanner = require('./scanner')
const Node = require('./node')

/**
 * @typedef {import('./node').DocumentNode} DocumentNode
 * @typedef {import('./node')} Node
 * @typedef {import('./scanner')} HtmlScanner
 */

/**
 * Parse html string.
 * @param {string} string The string to parse.
 * @param {object} [options] supported options.
 * @param {boolean} [options.wrapWithDocument=false] Whether force to create a document node as root wrapper.
 * @param {boolean} [options.ignoreWhitespaceText=true] Don't create text node when all the chars are white space.
 * @param {HtmlScanner} [options.scanner=HtmlScanner] Custom scanner, config it only when you want to implement complex logic.
 * @returns {Node[] | Node}
 */
const parse = (string, options) => {
    const { wrapWithDocument = false, ignoreWhitespaceText = true, scanner } = options || {}
    const parser = new Parser({
        scanner: scanner || new HtmlScanner({
            wrapWithDocument
        }),
        ignoreWhitespaceText
    })
    parser.parse(string)
    const root = parser.scanner.getRootNode()
    if (root.isVirtualRoot) {
        const nodes = root.childNodes
        nodes.forEach(v => (v.parentNode = null))
        return nodes
    } else {
        // Extra steps to handle white space or other characters before <html> tag.
        // 1. Remove text node(generated by white sapce), it's the same as browser.
        // 2. Do nothing for other nodes, it means document may has more than 2 child nodes.
        //    It's different from browser, but keep the same with browser will need more work,
        //    and it's not the goal of the lib.
        if (root.childNodes) {
            root.childNodes = root.childNodes.filter(node => {
                if (node.nodeType === Node.NODE_TYPE.TEXT_NODE && /^[\s\n\r]*$/.test(node.textContent)) {
                    return false
                }
                return true
            })
        }
    }
    return root
}

module.exports = parse
